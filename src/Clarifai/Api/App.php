<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: proto/clarifai/api/resources.proto

namespace Clarifai\Api;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 *&#47;/////////////////////////////////////////////////////////////////////////////
 * Messages from /proto/clarifai/api/app.proto
 * //////////////////////////////////////////////////////////////////////////////
 *
 * Generated from protobuf message <code>clarifai.api.App</code>
 */
class App extends \Google\Protobuf\Internal\Message
{
    /**
     * Generated from protobuf field <code>string id = 1;</code>
     */
    protected $id = '';
    /**
     * Generated from protobuf field <code>string name = 2;</code>
     */
    protected $name = '';
    /**
     * Generated from protobuf field <code>string default_language = 3;</code>
     */
    protected $default_language = '';
    /**
     * Generated from protobuf field <code>string default_workflow_id = 4;</code>
     */
    protected $default_workflow_id = '';
    /**
     *why is user_id present here when this message type is used in PostApps but completely ignored there? PostApp already specifies the userid in path but doesn't even actually use neither of userids, it instead used the id from auth context.
     *This creates a lot of ambiguity, should always have different message types for Post/Get endpoints so that the minimum interface for each op can be described
     *
     * Generated from protobuf field <code>string user_id = 5;</code>
     */
    protected $user_id = '';
    /**
     * When the app was created. We follow the XXXX timestamp
     * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
     * "2006-01-02T15:04:05.999999Z" so you can expect results like
     * the following from the API:
     * "2017-04-11T21:50:50.223962Z"
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp created_at = 6;</code>
     */
    protected $created_at = null;
    /**
     * if user accept legal consent for face recognition
     *
     * Generated from protobuf field <code>uint32 legal_consent_status = 7;</code>
     */
    protected $legal_consent_status = 0;
    /**
     * To handle arbitrary json metadata you can use a struct field:
     * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
     *
     * Generated from protobuf field <code>.google.protobuf.Struct metadata = 13;</code>
     */
    protected $metadata = null;
    /**
     * short description about the app.
     *
     * Generated from protobuf field <code>string description = 14;</code>
     */
    protected $description = '';
    /**
     * Default value for model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
     *
     * Generated from protobuf field <code>uint32 sample_ms = 15;</code>
     */
    protected $sample_ms = 0;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $id
     *     @type string $name
     *     @type string $default_language
     *     @type string $default_workflow_id
     *     @type string $user_id
     *          why is user_id present here when this message type is used in PostApps but completely ignored there? PostApp already specifies the userid in path but doesn't even actually use neither of userids, it instead used the id from auth context.
     *          This creates a lot of ambiguity, should always have different message types for Post/Get endpoints so that the minimum interface for each op can be described
     *     @type \Google\Protobuf\Timestamp $created_at
     *           When the app was created. We follow the XXXX timestamp
     *           format. We use https://www.ietf.org/rfc/rfc3339.txt format:
     *           "2006-01-02T15:04:05.999999Z" so you can expect results like
     *           the following from the API:
     *           "2017-04-11T21:50:50.223962Z"
     *     @type int $legal_consent_status
     *           if user accept legal consent for face recognition
     *     @type \Google\Protobuf\Struct $metadata
     *           To handle arbitrary json metadata you can use a struct field:
     *           https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
     *     @type string $description
     *           short description about the app.
     *     @type int $sample_ms
     *           Default value for model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Proto\Clarifai\Api\Resources::initOnce();
        parent::__construct($data);
    }

    /**
     * Generated from protobuf field <code>string id = 1;</code>
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * Generated from protobuf field <code>string id = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setId($var)
    {
        GPBUtil::checkString($var, True);
        $this->id = $var;

        return $this;
    }

    /**
     * Generated from protobuf field <code>string name = 2;</code>
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * Generated from protobuf field <code>string name = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setName($var)
    {
        GPBUtil::checkString($var, True);
        $this->name = $var;

        return $this;
    }

    /**
     * Generated from protobuf field <code>string default_language = 3;</code>
     * @return string
     */
    public function getDefaultLanguage()
    {
        return $this->default_language;
    }

    /**
     * Generated from protobuf field <code>string default_language = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setDefaultLanguage($var)
    {
        GPBUtil::checkString($var, True);
        $this->default_language = $var;

        return $this;
    }

    /**
     * Generated from protobuf field <code>string default_workflow_id = 4;</code>
     * @return string
     */
    public function getDefaultWorkflowId()
    {
        return $this->default_workflow_id;
    }

    /**
     * Generated from protobuf field <code>string default_workflow_id = 4;</code>
     * @param string $var
     * @return $this
     */
    public function setDefaultWorkflowId($var)
    {
        GPBUtil::checkString($var, True);
        $this->default_workflow_id = $var;

        return $this;
    }

    /**
     *why is user_id present here when this message type is used in PostApps but completely ignored there? PostApp already specifies the userid in path but doesn't even actually use neither of userids, it instead used the id from auth context.
     *This creates a lot of ambiguity, should always have different message types for Post/Get endpoints so that the minimum interface for each op can be described
     *
     * Generated from protobuf field <code>string user_id = 5;</code>
     * @return string
     */
    public function getUserId()
    {
        return $this->user_id;
    }

    /**
     *why is user_id present here when this message type is used in PostApps but completely ignored there? PostApp already specifies the userid in path but doesn't even actually use neither of userids, it instead used the id from auth context.
     *This creates a lot of ambiguity, should always have different message types for Post/Get endpoints so that the minimum interface for each op can be described
     *
     * Generated from protobuf field <code>string user_id = 5;</code>
     * @param string $var
     * @return $this
     */
    public function setUserId($var)
    {
        GPBUtil::checkString($var, True);
        $this->user_id = $var;

        return $this;
    }

    /**
     * When the app was created. We follow the XXXX timestamp
     * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
     * "2006-01-02T15:04:05.999999Z" so you can expect results like
     * the following from the API:
     * "2017-04-11T21:50:50.223962Z"
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp created_at = 6;</code>
     * @return \Google\Protobuf\Timestamp
     */
    public function getCreatedAt()
    {
        return $this->created_at;
    }

    /**
     * When the app was created. We follow the XXXX timestamp
     * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
     * "2006-01-02T15:04:05.999999Z" so you can expect results like
     * the following from the API:
     * "2017-04-11T21:50:50.223962Z"
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp created_at = 6;</code>
     * @param \Google\Protobuf\Timestamp $var
     * @return $this
     */
    public function setCreatedAt($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Timestamp::class);
        $this->created_at = $var;

        return $this;
    }

    /**
     * if user accept legal consent for face recognition
     *
     * Generated from protobuf field <code>uint32 legal_consent_status = 7;</code>
     * @return int
     */
    public function getLegalConsentStatus()
    {
        return $this->legal_consent_status;
    }

    /**
     * if user accept legal consent for face recognition
     *
     * Generated from protobuf field <code>uint32 legal_consent_status = 7;</code>
     * @param int $var
     * @return $this
     */
    public function setLegalConsentStatus($var)
    {
        GPBUtil::checkUint32($var);
        $this->legal_consent_status = $var;

        return $this;
    }

    /**
     * To handle arbitrary json metadata you can use a struct field:
     * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
     *
     * Generated from protobuf field <code>.google.protobuf.Struct metadata = 13;</code>
     * @return \Google\Protobuf\Struct
     */
    public function getMetadata()
    {
        return $this->metadata;
    }

    /**
     * To handle arbitrary json metadata you can use a struct field:
     * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
     *
     * Generated from protobuf field <code>.google.protobuf.Struct metadata = 13;</code>
     * @param \Google\Protobuf\Struct $var
     * @return $this
     */
    public function setMetadata($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Struct::class);
        $this->metadata = $var;

        return $this;
    }

    /**
     * short description about the app.
     *
     * Generated from protobuf field <code>string description = 14;</code>
     * @return string
     */
    public function getDescription()
    {
        return $this->description;
    }

    /**
     * short description about the app.
     *
     * Generated from protobuf field <code>string description = 14;</code>
     * @param string $var
     * @return $this
     */
    public function setDescription($var)
    {
        GPBUtil::checkString($var, True);
        $this->description = $var;

        return $this;
    }

    /**
     * Default value for model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
     *
     * Generated from protobuf field <code>uint32 sample_ms = 15;</code>
     * @return int
     */
    public function getSampleMs()
    {
        return $this->sample_ms;
    }

    /**
     * Default value for model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
     *
     * Generated from protobuf field <code>uint32 sample_ms = 15;</code>
     * @param int $var
     * @return $this
     */
    public function setSampleMs($var)
    {
        GPBUtil::checkUint32($var);
        $this->sample_ms = $var;

        return $this;
    }

}

