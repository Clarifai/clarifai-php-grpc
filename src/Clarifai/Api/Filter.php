<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: proto/clarifai/api/resources.proto

namespace Clarifai\Api;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Filter
 *
 * Generated from protobuf message <code>clarifai.api.Filter</code>
 */
class Filter extends \Google\Protobuf\Internal\Message
{
    /**
     * If True then this will flip the meaning of this part of the
     * query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
     *
     * Generated from protobuf field <code>bool negate = 3;</code>
     */
    protected $negate = false;
    /**
     * FILTER by annotation information.
     * ########## Supported fields ##########
     *  # Filter by ID fields
     *  - id                                      - example: `{"id": "xyz"}`
     *  - input_id
     *  - model_version_id
     *  - task_id
     *  - user_id
     *  # Filter by worker fields such as model, workflow and user IDs
     *  - worker.model.model_version.id
     *  - worker.user.id
     *  - worker.workflow.version.id
     *  # Filter by other top-level fields
     *  - annotation_info.fields                  - filter by annotation info
     *  - input_level                             - filter only input-level annotations
     *  - status.code                             - filter by annotation status code
     *  - trusted                                 - filter only trusted annotations
     *  # Filter by space-time info fields, i.e. region, frames and time-segments
     *  - data                                    - filter only annotations without space-time info, e.g. classifications
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {}}`
     *  - data.frames[].frame_info                - filter only frame annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"frames": [{"frame_info": {}}]}}`
     *  - data.regions[].region_info.bounding_box - filter only bounding box annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"bounding_box":{}}}]}}`
     *  - data.regions[].region_info.mask         - filter only mask annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"mask":{}}}]}}`
     *  - data.regions[].region_info.point        - filter only point annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"point":{}}}]}}`
     *  - data.regions[].region_info.polygon      - filter only polygon annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"polygon":{}}}]}}`
     *  - data.regions[].region_info.span         - filter only span annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"span":{}}}]}}`
     *  - data.regions[].track_id                 - filter annotations by track_id
     *                                            - in order to enable this, you need to provide "track_id_value" i.e. `{"data": {"regions": [{"track_id" : "track_id_value"}]}}`
     *  - data.time_segments[].time_info          - filter only time-segment annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"time_segments": [{"time_info": {}}]}}`
     *  # Filter by other data fields
     *  - data.clusters[].id
     *  - data.concepts[].id
     *  - data.concepts[].name
     *  - data.concepts[].value
     *  - data.geo.geo_box[].geo_point.latitude
     *  - data.geo.geo_box[].geo_point.longitude
     *  - data.geo.geo_limit.type
     *  - data.geo.geo_limit.value
     *  - data.geo.geo_point.latitude
     *  - data.geo.geo_point.longitude
     *  - data.metadata.fields                    - filter by metadata
     *                                            - Important to note: metadata key&value fields are OR-ed.
     *                                            - example with 1 metadata key: searching by
     *                                                      `{
     *                                                      `  "data": {
     *                                                      `    "metadata": {
     *                                                      `      "fields": {
     *                                                      `        "foo": {
     *                                                      `          "string_value": "bar"
     *                                                      `        },
     *                                                      `      }
     *                                                      `    }
     *                                                      `  }
     *                                                      `}
     *                                                      will result in a search condition like `metadata includes {"foo": "bar}`;
     *                                            - example with 2 metadata keys: searching by
     *                                                      `{
     *                                                      `  "data": {
     *                                                      `    "metadata": {
     *                                                      `      "fields": {
     *                                                      `        "foo1": {
     *                                                      `          "string_value": "bar2"
     *                                                      `        },
     *                                                      `        "foo2": {
     *                                                      `          "string_value": "bar2"
     *                                                      `        }
     *                                                      `      }
     *                                                      `    }
     *                                                      `  }
     *                                                      `}
     *                                                      will result in a search condition like `(metadata includes {"foo1": "bar1"}) OR (metadata includes {"foo2": "bar2"})`.
     *  - data.text                               - filter only text annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"text": {}}}`
     *
     * Generated from protobuf field <code>.clarifai.api.Annotation annotation = 4;</code>
     */
    protected $annotation = null;
    /**
     * FILTER by input information.
     * ########## Supported fields ##########
     *  - data.audio                              - filter only audio inputs
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"audio": {}}`
     *  - data.image                              - filter only image inputs
     *                                            - enable using `{"image": {}}`
     *  - data.text                               - filter only text inputs
     *                                            - enable using `{"text": {}}`
     *  - data.video                              - filter only video inputs
     *                                            - enable using `{"video": {}}`
     *  - dataset_ids[]                           - filter by dataset IDs
     *                                            - example: `{"dataset_ids": ["d1", "d2"]}` will filter for inputs in d1 OR d2
     *  - status.code                             - filter by input status
     *                                            - example: `{"status": {"code": 30000}}` to filter only for SUCCESS inputs
     *
     * Generated from protobuf field <code>.clarifai.api.Input input = 5;</code>
     */
    protected $input = null;
    /**
     * Filter by annotation last updated time range.
     *
     * Generated from protobuf field <code>.clarifai.api.TimeRange last_updated_time_range = 6;</code>
     */
    protected $last_updated_time_range = null;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type bool $negate
     *           If True then this will flip the meaning of this part of the
     *           query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
     *     @type \Clarifai\Api\Annotation $annotation
     *           FILTER by annotation information.
     *           ########## Supported fields ##########
     *            # Filter by ID fields
     *            - id                                      - example: `{"id": "xyz"}`
     *            - input_id
     *            - model_version_id
     *            - task_id
     *            - user_id
     *            # Filter by worker fields such as model, workflow and user IDs
     *            - worker.model.model_version.id
     *            - worker.user.id
     *            - worker.workflow.version.id
     *            # Filter by other top-level fields
     *            - annotation_info.fields                  - filter by annotation info
     *            - input_level                             - filter only input-level annotations
     *            - status.code                             - filter by annotation status code
     *            - trusted                                 - filter only trusted annotations
     *            # Filter by space-time info fields, i.e. region, frames and time-segments
     *            - data                                    - filter only annotations without space-time info, e.g. classifications
     *                                                      - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {}}`
     *            - data.frames[].frame_info                - filter only frame annotations
     *                                                      - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"frames": [{"frame_info": {}}]}}`
     *            - data.regions[].region_info.bounding_box - filter only bounding box annotations
     *                                                      - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"bounding_box":{}}}]}}`
     *            - data.regions[].region_info.mask         - filter only mask annotations
     *                                                      - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"mask":{}}}]}}`
     *            - data.regions[].region_info.point        - filter only point annotations
     *                                                      - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"point":{}}}]}}`
     *            - data.regions[].region_info.polygon      - filter only polygon annotations
     *                                                      - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"polygon":{}}}]}}`
     *            - data.regions[].region_info.span         - filter only span annotations
     *                                                      - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"span":{}}}]}}`
     *            - data.regions[].track_id                 - filter annotations by track_id
     *                                                      - in order to enable this, you need to provide "track_id_value" i.e. `{"data": {"regions": [{"track_id" : "track_id_value"}]}}`
     *            - data.time_segments[].time_info          - filter only time-segment annotations
     *                                                      - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"time_segments": [{"time_info": {}}]}}`
     *            # Filter by other data fields
     *            - data.clusters[].id
     *            - data.concepts[].id
     *            - data.concepts[].name
     *            - data.concepts[].value
     *            - data.geo.geo_box[].geo_point.latitude
     *            - data.geo.geo_box[].geo_point.longitude
     *            - data.geo.geo_limit.type
     *            - data.geo.geo_limit.value
     *            - data.geo.geo_point.latitude
     *            - data.geo.geo_point.longitude
     *            - data.metadata.fields                    - filter by metadata
     *                                                      - Important to note: metadata key&value fields are OR-ed.
     *                                                      - example with 1 metadata key: searching by
     *                                                                `{
     *                                                                `  "data": {
     *                                                                `    "metadata": {
     *                                                                `      "fields": {
     *                                                                `        "foo": {
     *                                                                `          "string_value": "bar"
     *                                                                `        },
     *                                                                `      }
     *                                                                `    }
     *                                                                `  }
     *                                                                `}
     *                                                                will result in a search condition like `metadata includes {"foo": "bar}`;
     *                                                      - example with 2 metadata keys: searching by
     *                                                                `{
     *                                                                `  "data": {
     *                                                                `    "metadata": {
     *                                                                `      "fields": {
     *                                                                `        "foo1": {
     *                                                                `          "string_value": "bar2"
     *                                                                `        },
     *                                                                `        "foo2": {
     *                                                                `          "string_value": "bar2"
     *                                                                `        }
     *                                                                `      }
     *                                                                `    }
     *                                                                `  }
     *                                                                `}
     *                                                                will result in a search condition like `(metadata includes {"foo1": "bar1"}) OR (metadata includes {"foo2": "bar2"})`.
     *            - data.text                               - filter only text annotations
     *                                                      - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"text": {}}}`
     *     @type \Clarifai\Api\Input $input
     *           FILTER by input information.
     *           ########## Supported fields ##########
     *            - data.audio                              - filter only audio inputs
     *                                                      - in order to enable this, you need to set the field to an empty object, i.e. `{"audio": {}}`
     *            - data.image                              - filter only image inputs
     *                                                      - enable using `{"image": {}}`
     *            - data.text                               - filter only text inputs
     *                                                      - enable using `{"text": {}}`
     *            - data.video                              - filter only video inputs
     *                                                      - enable using `{"video": {}}`
     *            - dataset_ids[]                           - filter by dataset IDs
     *                                                      - example: `{"dataset_ids": ["d1", "d2"]}` will filter for inputs in d1 OR d2
     *            - status.code                             - filter by input status
     *                                                      - example: `{"status": {"code": 30000}}` to filter only for SUCCESS inputs
     *     @type \Clarifai\Api\TimeRange $last_updated_time_range
     *           Filter by annotation last updated time range.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Proto\Clarifai\Api\Resources::initOnce();
        parent::__construct($data);
    }

    /**
     * If True then this will flip the meaning of this part of the
     * query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
     *
     * Generated from protobuf field <code>bool negate = 3;</code>
     * @return bool
     */
    public function getNegate()
    {
        return $this->negate;
    }

    /**
     * If True then this will flip the meaning of this part of the
     * query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
     *
     * Generated from protobuf field <code>bool negate = 3;</code>
     * @param bool $var
     * @return $this
     */
    public function setNegate($var)
    {
        GPBUtil::checkBool($var);
        $this->negate = $var;

        return $this;
    }

    /**
     * FILTER by annotation information.
     * ########## Supported fields ##########
     *  # Filter by ID fields
     *  - id                                      - example: `{"id": "xyz"}`
     *  - input_id
     *  - model_version_id
     *  - task_id
     *  - user_id
     *  # Filter by worker fields such as model, workflow and user IDs
     *  - worker.model.model_version.id
     *  - worker.user.id
     *  - worker.workflow.version.id
     *  # Filter by other top-level fields
     *  - annotation_info.fields                  - filter by annotation info
     *  - input_level                             - filter only input-level annotations
     *  - status.code                             - filter by annotation status code
     *  - trusted                                 - filter only trusted annotations
     *  # Filter by space-time info fields, i.e. region, frames and time-segments
     *  - data                                    - filter only annotations without space-time info, e.g. classifications
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {}}`
     *  - data.frames[].frame_info                - filter only frame annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"frames": [{"frame_info": {}}]}}`
     *  - data.regions[].region_info.bounding_box - filter only bounding box annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"bounding_box":{}}}]}}`
     *  - data.regions[].region_info.mask         - filter only mask annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"mask":{}}}]}}`
     *  - data.regions[].region_info.point        - filter only point annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"point":{}}}]}}`
     *  - data.regions[].region_info.polygon      - filter only polygon annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"polygon":{}}}]}}`
     *  - data.regions[].region_info.span         - filter only span annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"span":{}}}]}}`
     *  - data.regions[].track_id                 - filter annotations by track_id
     *                                            - in order to enable this, you need to provide "track_id_value" i.e. `{"data": {"regions": [{"track_id" : "track_id_value"}]}}`
     *  - data.time_segments[].time_info          - filter only time-segment annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"time_segments": [{"time_info": {}}]}}`
     *  # Filter by other data fields
     *  - data.clusters[].id
     *  - data.concepts[].id
     *  - data.concepts[].name
     *  - data.concepts[].value
     *  - data.geo.geo_box[].geo_point.latitude
     *  - data.geo.geo_box[].geo_point.longitude
     *  - data.geo.geo_limit.type
     *  - data.geo.geo_limit.value
     *  - data.geo.geo_point.latitude
     *  - data.geo.geo_point.longitude
     *  - data.metadata.fields                    - filter by metadata
     *                                            - Important to note: metadata key&value fields are OR-ed.
     *                                            - example with 1 metadata key: searching by
     *                                                      `{
     *                                                      `  "data": {
     *                                                      `    "metadata": {
     *                                                      `      "fields": {
     *                                                      `        "foo": {
     *                                                      `          "string_value": "bar"
     *                                                      `        },
     *                                                      `      }
     *                                                      `    }
     *                                                      `  }
     *                                                      `}
     *                                                      will result in a search condition like `metadata includes {"foo": "bar}`;
     *                                            - example with 2 metadata keys: searching by
     *                                                      `{
     *                                                      `  "data": {
     *                                                      `    "metadata": {
     *                                                      `      "fields": {
     *                                                      `        "foo1": {
     *                                                      `          "string_value": "bar2"
     *                                                      `        },
     *                                                      `        "foo2": {
     *                                                      `          "string_value": "bar2"
     *                                                      `        }
     *                                                      `      }
     *                                                      `    }
     *                                                      `  }
     *                                                      `}
     *                                                      will result in a search condition like `(metadata includes {"foo1": "bar1"}) OR (metadata includes {"foo2": "bar2"})`.
     *  - data.text                               - filter only text annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"text": {}}}`
     *
     * Generated from protobuf field <code>.clarifai.api.Annotation annotation = 4;</code>
     * @return \Clarifai\Api\Annotation|null
     */
    public function getAnnotation()
    {
        return $this->annotation;
    }

    public function hasAnnotation()
    {
        return isset($this->annotation);
    }

    public function clearAnnotation()
    {
        unset($this->annotation);
    }

    /**
     * FILTER by annotation information.
     * ########## Supported fields ##########
     *  # Filter by ID fields
     *  - id                                      - example: `{"id": "xyz"}`
     *  - input_id
     *  - model_version_id
     *  - task_id
     *  - user_id
     *  # Filter by worker fields such as model, workflow and user IDs
     *  - worker.model.model_version.id
     *  - worker.user.id
     *  - worker.workflow.version.id
     *  # Filter by other top-level fields
     *  - annotation_info.fields                  - filter by annotation info
     *  - input_level                             - filter only input-level annotations
     *  - status.code                             - filter by annotation status code
     *  - trusted                                 - filter only trusted annotations
     *  # Filter by space-time info fields, i.e. region, frames and time-segments
     *  - data                                    - filter only annotations without space-time info, e.g. classifications
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {}}`
     *  - data.frames[].frame_info                - filter only frame annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"frames": [{"frame_info": {}}]}}`
     *  - data.regions[].region_info.bounding_box - filter only bounding box annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"bounding_box":{}}}]}}`
     *  - data.regions[].region_info.mask         - filter only mask annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"mask":{}}}]}}`
     *  - data.regions[].region_info.point        - filter only point annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"point":{}}}]}}`
     *  - data.regions[].region_info.polygon      - filter only polygon annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"polygon":{}}}]}}`
     *  - data.regions[].region_info.span         - filter only span annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"regions": [{"region_info": {"span":{}}}]}}`
     *  - data.regions[].track_id                 - filter annotations by track_id
     *                                            - in order to enable this, you need to provide "track_id_value" i.e. `{"data": {"regions": [{"track_id" : "track_id_value"}]}}`
     *  - data.time_segments[].time_info          - filter only time-segment annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"time_segments": [{"time_info": {}}]}}`
     *  # Filter by other data fields
     *  - data.clusters[].id
     *  - data.concepts[].id
     *  - data.concepts[].name
     *  - data.concepts[].value
     *  - data.geo.geo_box[].geo_point.latitude
     *  - data.geo.geo_box[].geo_point.longitude
     *  - data.geo.geo_limit.type
     *  - data.geo.geo_limit.value
     *  - data.geo.geo_point.latitude
     *  - data.geo.geo_point.longitude
     *  - data.metadata.fields                    - filter by metadata
     *                                            - Important to note: metadata key&value fields are OR-ed.
     *                                            - example with 1 metadata key: searching by
     *                                                      `{
     *                                                      `  "data": {
     *                                                      `    "metadata": {
     *                                                      `      "fields": {
     *                                                      `        "foo": {
     *                                                      `          "string_value": "bar"
     *                                                      `        },
     *                                                      `      }
     *                                                      `    }
     *                                                      `  }
     *                                                      `}
     *                                                      will result in a search condition like `metadata includes {"foo": "bar}`;
     *                                            - example with 2 metadata keys: searching by
     *                                                      `{
     *                                                      `  "data": {
     *                                                      `    "metadata": {
     *                                                      `      "fields": {
     *                                                      `        "foo1": {
     *                                                      `          "string_value": "bar2"
     *                                                      `        },
     *                                                      `        "foo2": {
     *                                                      `          "string_value": "bar2"
     *                                                      `        }
     *                                                      `      }
     *                                                      `    }
     *                                                      `  }
     *                                                      `}
     *                                                      will result in a search condition like `(metadata includes {"foo1": "bar1"}) OR (metadata includes {"foo2": "bar2"})`.
     *  - data.text                               - filter only text annotations
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"data": {"text": {}}}`
     *
     * Generated from protobuf field <code>.clarifai.api.Annotation annotation = 4;</code>
     * @param \Clarifai\Api\Annotation $var
     * @return $this
     */
    public function setAnnotation($var)
    {
        GPBUtil::checkMessage($var, \Clarifai\Api\Annotation::class);
        $this->annotation = $var;

        return $this;
    }

    /**
     * FILTER by input information.
     * ########## Supported fields ##########
     *  - data.audio                              - filter only audio inputs
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"audio": {}}`
     *  - data.image                              - filter only image inputs
     *                                            - enable using `{"image": {}}`
     *  - data.text                               - filter only text inputs
     *                                            - enable using `{"text": {}}`
     *  - data.video                              - filter only video inputs
     *                                            - enable using `{"video": {}}`
     *  - dataset_ids[]                           - filter by dataset IDs
     *                                            - example: `{"dataset_ids": ["d1", "d2"]}` will filter for inputs in d1 OR d2
     *  - status.code                             - filter by input status
     *                                            - example: `{"status": {"code": 30000}}` to filter only for SUCCESS inputs
     *
     * Generated from protobuf field <code>.clarifai.api.Input input = 5;</code>
     * @return \Clarifai\Api\Input|null
     */
    public function getInput()
    {
        return $this->input;
    }

    public function hasInput()
    {
        return isset($this->input);
    }

    public function clearInput()
    {
        unset($this->input);
    }

    /**
     * FILTER by input information.
     * ########## Supported fields ##########
     *  - data.audio                              - filter only audio inputs
     *                                            - in order to enable this, you need to set the field to an empty object, i.e. `{"audio": {}}`
     *  - data.image                              - filter only image inputs
     *                                            - enable using `{"image": {}}`
     *  - data.text                               - filter only text inputs
     *                                            - enable using `{"text": {}}`
     *  - data.video                              - filter only video inputs
     *                                            - enable using `{"video": {}}`
     *  - dataset_ids[]                           - filter by dataset IDs
     *                                            - example: `{"dataset_ids": ["d1", "d2"]}` will filter for inputs in d1 OR d2
     *  - status.code                             - filter by input status
     *                                            - example: `{"status": {"code": 30000}}` to filter only for SUCCESS inputs
     *
     * Generated from protobuf field <code>.clarifai.api.Input input = 5;</code>
     * @param \Clarifai\Api\Input $var
     * @return $this
     */
    public function setInput($var)
    {
        GPBUtil::checkMessage($var, \Clarifai\Api\Input::class);
        $this->input = $var;

        return $this;
    }

    /**
     * Filter by annotation last updated time range.
     *
     * Generated from protobuf field <code>.clarifai.api.TimeRange last_updated_time_range = 6;</code>
     * @return \Clarifai\Api\TimeRange|null
     */
    public function getLastUpdatedTimeRange()
    {
        return $this->last_updated_time_range;
    }

    public function hasLastUpdatedTimeRange()
    {
        return isset($this->last_updated_time_range);
    }

    public function clearLastUpdatedTimeRange()
    {
        unset($this->last_updated_time_range);
    }

    /**
     * Filter by annotation last updated time range.
     *
     * Generated from protobuf field <code>.clarifai.api.TimeRange last_updated_time_range = 6;</code>
     * @param \Clarifai\Api\TimeRange $var
     * @return $this
     */
    public function setLastUpdatedTimeRange($var)
    {
        GPBUtil::checkMessage($var, \Clarifai\Api\TimeRange::class);
        $this->last_updated_time_range = $var;

        return $this;
    }

}

